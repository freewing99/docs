{% block docTitle %}{% endblock %}

数据对象之间存在 3 种类型的关系：

* **一对一**关系：将一个对象与另一个对象关联。
* **一对多**关系：让一个对象关联多个对象。
* **多对多**关系：可以实现大量对象之间的复杂关联。

## 关系构建方式
LeanCloud 提供 4 种方式来构建对象之间的关系：

方式|适用的关系类型
---|---
Pointers|一对一、一对多
Arrays|一对多、多对多
AVRelation|多对多
关联表|多对多

## 一对多关系
当你需要一个「一对多」关系的时候，该使用 Pointers 还是 Arrays 来实现，首先要考虑关系中包含的对象数量。如果关系「多」方包含的对象数量可能非常大（大于 100 左右），那么你就必须使用 Pointers。反之，如果对象数量很小（低于 100 或更少），那么 Arrays 可能会更方便，特别是如果你经常需要获取父对象同时得到所有相关的对象（一对多关系中的「多」）。

### 使用 Pointers 实现一对多关系
假如我们设计一个类微博的应用，每一个用户都会发送多条微博，但是一条微博的原作者有且仅有一个，这是一个典型的一对多的用户场景，现在我们用 `Post` 来表示微博对象，我们确定每个 `Post` 对象都会与一个 AVUser，也就是微博的作者相关联。我们可以像这样实现：

{% block postPointToAVUser %}{% endblock %}

我们可以使用下面的代码来查询某个 AVUser 创建的 `Post` 对象：

{% block queryPostByAVUser %}{% endblock %}

如果我们需要查询某个 `Post` 对象的创建者，也就是获取 `postedBy ` 属性：

{% block queryCreaterForPost %}{% endblock %}

大多数场景下，Pointers 是实现一对多关系的最好选择。

### 使用 Arrays 实现一对多关系
当一对多关系中包含的对象数量很小，使用 Arrays 实现会比较理想。Arrays 可以通过 `includeKey` 简化查询。传递对应的 key 可以在获取「一」方对象数据的同时获取到所有「多」方对象的数据。但是，如果关系中包含的对象数量巨大，查询将响应缓慢。

假设在我们的微博系统中，我们想保存用户关注的话题列表，这样可以方便用户根据话题关键字直接搜索相关的微博。这种情况正好适合用 Arrays 实现，而且还需要保存用户每次修改后数组内元素的顺序，方便用户随时修改自己关注的话题的优先级：

我们可以在 AVUser 上创建添加一列 `topicList`。

现在我们存入一些 `Topic` 对象到 `topicList` 中：

{% block addTopicListToAVUser %}{% endblock %}

然后，如果我们需要获取这些 `Topic` 对象，仅仅需要一行代码：

{% block addTopicListToAVUser %}{% endblock %}

如果想在获取一对多中「一」的对象的同时获取「多」的对象，则可以在使用 AVQuery 查询 AVUser 的时候，使用 `includeKey`（或 Android 中的 `include`）来同时获取 `topicList` 列中存放的 `Topic` 对象：

{% block queryIncludeTopicList %}{% endblock %}


你也可以在一对多关系中通过「多」方对象获取到「一」方对象。例如，我们想找出关注了某个特定微博话题的所有 AVUser，可以像这样来查询：

{% block queryAVUserContainsTopic %}{% endblock %}

## 多对多关系
现在让我们来处理多对多关系。假设我们有一个读书应用，我们需要对 Book 对象和 Author 对象建模。如我们所知，一个作者可以写多本书，一本书也可以有多个作者。这是一个典型的多对多关系，你必须选择使用 Arrays、AVRelation 或创建自己的关联表来实现这种关系。

决策的关键在于是否需要为这个关系附加一些属性。如果不需要，使用 AVRelation 或 Arrays 是最简单的。通常情况下，使用 Arrays 会有更好的性能和更少的查询。如果多对多关系中任何一方对象数量可能达到或超过 100，像一对多关系中描述的原因一样，使用 AVRelation 或关联表是更好的选择。

另一方面，如果你想为关系附加一些属性，则需要创建一个独立的表（关联表）来存储两端的关系。记住，附加的属性是描述这个关系的，不是描述关系中的任何一方，比如：

* 关系创建的时间
* 关系创建者
* 某人查看此关系的次数

### 使用 AVRelation
我们可以使用 AVRelation 构建一个 Student 和 Course 之间的关系。一个学生可以学习「多」门课程，一门课程也可以拥有「多」个学生。

{% block studentAVRelationCourse %}{% endblock %}

要获取学习某个课程的所有学生，使用如下查询：

{% block queryStudentByCourse %}{% endblock %}

要获取某个学生学习的所有课程，可以构造一个稍微不同的查询来获取这种反向关系的结果：

{% block queryCoursesByStudent %}{% endblock %}

### 使用关联表
在有些场景中，我们需要知道更多关系的附加信息，比如学生选课的系统中，如果要了解学生何时选修的这门课，或者学生是通过手机还是网站完成的选修操作，这个时候单独使用 `AVRelation` 就无法满足需求，因为 `AVRelation` 不支持额外的自定义属性，此时我们可以使用传统的数据库设计方法：关联表。

要实现这个需求，我们创建一个独立的表保存 Student 和 Course 的关系，表名暂且叫 `CourseChoosing`，它包含以下几个字段：

字段名|数据类型|描述
---|---|---
course|指针实例|课程
student|指针实例|学生
date|Date|选修的时间
platform|String|操作时使用的设备

实现选修功能的代码如下：

{% block relationTableStudentCourse %}{% endblock %}

如果想查询选修了某一课程的所有学生，可以进行如下操作：

{% block relationTableQueryStudentInCourse %}{% endblock %}

同样，我们也可以很简单地检索到某一个学生选修的所有课程：

{% block relationTableQueryCourseOfStudent %}{% endblock %}

### 使用 Arrays 实现多对多关系
使用 Arrays 实现多对多关系跟实现一对多关系大致相同。关系中一方的所有对象拥有一个数组列包含一些关系另一方的对象。

假如我们开发一个社交类的应用，每位注册用户可以标注自己喜欢的异性类型（Tag），我们知道一个正常的用户感兴趣的类型是有限的，比如贝克汉姆可能会喜欢 `Hot`、`Sexy`的，贾斯丁比伯可能喜欢 `Foolish`、`Nonage`，使用 Arrays 实现就非常符合这样的场景，我们只要在用户表添加一个数组字段记录用户关注的类型（FocusTags）。

以下代码演示用户注册成功之后，添加自己关注的类型:

{% block addFocusTagsForAVUserUsingArray %}{% endblock %}

当一个用户想查看自己目前关注了哪些类型的时候，则在查询中使用 `include` 操作来获取对应的数组值： 

{% block queryFocusTagsForAVUserUsingInclude %}{% endblock %}

假如想搜索所有关注了 `Hot` 类型的用户，可以如下操作：

{% block queryAVUserFocusHotTag %}{% endblock %}

## 一对一关系
当你需要将一个对象拆分成两个对象时，一对一关系是一种重要的需求。这种需求应该不常见，列举如下：

* **限制部分用户数据的权限**：你可以将此对象拆分成两部分，一部分包含所有用户可见的数据，另一部分包含所有仅自己可见的数据（通过 ACL 控制）。同样，你也可以实现一部分包含所有用户可修改的数据，另一部分包含所有仅自己可修改的数据。
* **避免大对象**：你的原始对象大小超出了对象的上限值 128 KB，你可以创建另一个对象来存储额外的数据。当然，这通常需要更好地设计你的数据模型来避免出现大对象。如果确实无法避免，你也可以考虑使用 AVFile 存储大数据。
* **更灵活的文件对象**：AVFile 可以方便地存取文件，但是作为对象查询修改等不是很方便，这时可以使用 AVObject 构造一个自己的文件对象并与 AVFile 一对一关联，将文件属性存于 AVObject 中，这样既可以方便查询修改文件属性，也可以方便存取文件。

数据的关系建模一直是一个复杂而难于描述和理解的话题，为此我们要向阅读至此的读者表示感谢和敬意，不过乐观一点来说，它仍然比人际关系要简单许多。
